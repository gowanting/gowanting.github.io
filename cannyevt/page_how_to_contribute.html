<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Canny-EVT: How to contribute</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Canny-EVT
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">The OpenGV library</a></li>  </ul>
</div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">How to contribute</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>You are missing your geometric vision algorithm? You share the feeling that it would be nice to have a common place for all geometric vision algorithms, which then implicitly would offer automatic benchmarking without having to do the overhead everyime? Well, that place is here! Join the community today and add your algorithm(s). The instructions on this page give you some additional hints if you want to participate.</p>
<h1><a class="anchor" id="sec_contribute_1"></a>
Preparations</h1>
<p>If you haven't done so, please follow the instructions in the "Installation"-section to install the library on your system. We strongly recommend that you are using github's fork/pull request mechanism. It is also recommended that you first collect some experience with using the library, and notably understand the interface of the library. Please checkout the section "How to use".</p>
<h1><a class="anchor" id="sec_contribute_2"></a>
Design concepts:</h1>
<p>The library is developped in C++. The interface is based on the adapter-pattern, and you should use this concept in order to keep things as compatible as possible. In essence, it means that you should reuse the base-classes AbsoluteAdapterBase and RelativeAdapterBase, no matter if implementing a new algorithm or if extending the portability by implementing a new adapter. Have a look at the "How to use"-section in order to get more information.</p>
<p>You should also make yourself familiar with some coding standards. The code written so far doesn't necessarily follow one standard exclusively, but at least reflects the effort of maintaining a reasonable level of consistency. Please try to follow that line, it will substantially facilitate the inclusion of your code. Also have a look at the directory structure, it strictly follows the namespace structure, and this should remain the case. Headers that are only intended for internal use are in sub-folders called "modules", and templated implementation-headers go into sub-directories called "implementation". Also have a look at types.hpp, these are the types used for all geometric vision constructs, and should be reused thoughout the entire library. OpenGV uses two-space indentation, and tries to stick to 80-column width.</p>
<p>Another property that should be maintened is "independence". The library essentially depends only on Eigen. This is a powerful library that should deliver most of the functionality required for the purpose of opengv. For the sake of simplicity of installation and contribution, we should keep things along these lines, which means that it is appreciated if algorithms do not require the inclusion of any further third-party libraries.</p>
<p>The files in the library are encoded with UTF-8. It has been mainly developed under Linux, and compilation with gcc currently returns no warnings (hopefully). If you plan to develop under Windows, make sure you use an editor that understands UTF-8 encoding (no, notepad.exe is not a nice editor ;) ).</p>
<h1><a class="anchor" id="sec_contribute_3"></a>
Todos:</h1>
<p>The following is a non-exhaustive list of things that could be improved. You may also want to contact <a href="#" onclick="location.href='mai'+'lto:'+'kne'+'ip'+'.la'+'ur'+'ent'+'@g'+'mai'+'l.'+'com'; return false;">kneip<span class="obfuscator">.nosp@m.</span>.lau<span class="obfuscator">.nosp@m.</span>rent@<span class="obfuscator">.nosp@m.</span>gmai<span class="obfuscator">.nosp@m.</span>l.com</a> for further information, if you want to collaborate on one of these points.</p>
<ul>
<li>
The library should easily permit further benchmarks, for instance all the special cases (e.g. planar structure etc.). </li>
<li>
The triangulation method needs to be able to handle non-central viewpoints. This would avoid some hacks here and there. Same accounts for the point-cloud alignment methods. </li>
<li>
The triangulation methods (and possibly further algorithms) should be included in the opengv-Matlab-interface. </li>
<li>
NoncentralRelativePoseSacProblem could decide automatically whether it should process data in a central or non-central way. Same accounts for the MultiNoncentralRelativePoseSacProblem. </li>
<li>
Sometimes ransac or iterative methods reset the adapter transformation for instance to compute reprojection errors (search recursively for sett). The original value should always be reset, because other parts of the algorithm potentially want to use it. </li>
<li>
Add more adapters to increase the portability. Examples are: OpenCV, Gandalf, VXR, Bundler, libcvd, OpenMVG. </li>
<li>
There is an improved version of p3p_kneip lying around somewhere, which could be included. </li>
<li>
Richard Hartley's implementation of the five-point should be included (replacing the current one). </li>
<li>
Hongdong Li's five-point solver should be included. </li>
<li>
Kukelova's polynomial eigenvalue solution could be included. </li>
<li>
P4P and DLT should be included. </li>
<li>
What about DLS and OPnP? Only Matlab versions are publically available. </li>
<li>
The 6-point by Stewenius is extremly difficult to reimplement. The reimplementation I provide is maybe not the best. </li>
<li>
Most of the current implementations treat the correspondences equally. The AdapterBase-classes however contain already a virtual function called "getWeight", which could be used to weight the correspondences differently for instance in a non-linear optimization scheme. Most of the adapters currently simply return 1.0 for these calls. Only the CentralRelativeWeightingAdapter has constructors that include the weight of the correspondences. </li>
<li>
arun_complete and threept_arun are redundant, we should get rid of one of them. </li>
<li>
The polynomial structures are Matlab-like arrays of coefficients, of different types, and sometimes with different conventions (coefficients once stored along the lines, once along the columns). </li>
<li>
Add more comments in implementation files such that users can potentially understand what's going on. </li>
<li>
Use vector.segment, block...topleftcorner etc. </li>
<li>
Theia by Chris Sweeney has an interesting Sturm root finder, it could be transplanted. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
